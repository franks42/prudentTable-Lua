<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>LuaDoc</h1>
<ul>
	
	<li><a href="../index.html">Index</a></li>
	
</ul>


<!-- Module list -->



<!-- File list -->

<h1>Files</h1>
<ul>

	<li><strong>prudentTable.lua</strong></li>
	
</ul>






</div> <!-- id="navigation" -->

<div id="content">

<h1>File <code>prudentTable.lua</code></h1>







<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#pT.arrayPairs">pT.arrayPairs</a>&nbsp;(t, i)</td>
	<td class="summary">ipairs-replacement for pTable t's array-component that iterates up from t[1] till t[len(t)], and will return possible nil-values.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.arrayPairsSkipNil">pT.arrayPairsSkipNil</a>&nbsp;(t, i)</td>
	<td class="summary">ipairs-replacement for pTable t's array-component that iterates up from t[1] till t[len(t)], and will skip any nil-values.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.deepCompare">pT.deepCompare</a>&nbsp;(t1, t2)</td>
	<td class="summary">Returns result from a deep-compare of object t1 and t2 - compare by value for table elements - iterates down the trees - circular and repeated reference detection.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.deepCopy">pT.deepCopy</a>&nbsp;(t)</td>
	<td class="summary">Returns a deep copy of object t - iterates "down" the tree if t is a table - pTable-aware - multiple&circular reference aware - copy will share metatable with source.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.get">pT.get</a>&nbsp;(t, i)</td>
	<td class="summary">Returns the array-element value at index i of pTable t.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.getRL">pT.getRL</a>&nbsp;(t, b, e)</td>
	<td class="summary">For the range of array-index b till e of pTable t, returns the list of element values.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.getRT">pT.getRT</a>&nbsp;(t, b, e)</td>
	<td class="summary">For the range of array-index b till e of pTable t, returns an array of element values as a new pTable.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.insert">pT.insert</a>&nbsp;(t, iOrV, ...)</td>
	<td class="summary">Extends and inserts a single value at index i of pTable t - Array-size is increased by one to accomodate the new entry.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.insertL">pT.insertL</a>&nbsp;(t, i, ...)</td>
	<td class="summary">Inserts a list of values at index i of pTable t - Array-size is increased to accomodate the list of values.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.insertT">pT.insertT</a>&nbsp;(t, i, ...)</td>
	<td class="summary">Inserts the array-elements of a list of pTable's at index i of pTable t.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.isIndex">pT.isIndex</a>&nbsp;(t, k)</td>
	<td class="summary">Returns whether the key k is a valid index for the array-component of pTable t.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.isLuaTableLenOK">pT.isLuaTableLenOK</a>&nbsp;(lt)</td>
	<td class="summary">Returns whether the Lua table lt's length may be ambiguous by comparing lt's non-nil array size (nonNilLen(t)) with #lt.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.isPTable">pT.isPTable</a>&nbsp;(t)</td>
	<td class="summary">Returns whether the t is registered as a pTable.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.len">pT.len</a>&nbsp;(t)</td>
	<td class="summary">Returns length/size of the array component of pTable t.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.lenT">pT.lenT</a>&nbsp;(...)</td>
	<td class="summary">Returns the sum of the array-lengths of a list of pTables: len(t1)+...+len(tn).</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.listPairs">pT.listPairs</a>&nbsp;(...)</td>
	<td class="summary">ipairs-like iterator for varargs (friendly to nils).</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.listPairsSkipNil">pT.listPairsSkipNil</a>&nbsp;(...)</td>
	<td class="summary">Iterator for varargs (friendly to nils).</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.mapKeys">pT.mapKeys</a>&nbsp;(t)</td>
	<td class="summary">Returns a list of all the keys of the map-component of pTable t without the array-indices.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.mapKeysT">pT.mapKeysT</a>&nbsp;(t)</td>
	<td class="summary">Returns a pTable with a list of all the keys of the map-component of pTable t without the array-indices.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.mapLen">pT.mapLen</a>&nbsp;(t)</td>
	<td class="summary">Returns the number of map entries in pTable t that are not part of the array-component.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.mapNext">pT.mapNext</a>&nbsp;(t, k)</td>
	<td class="summary">Next-like iterator that excludes any keys k of pTable t that are array indices - Only iterates over the map-component of the pTable.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.mapPairs">pT.mapPairs</a>&nbsp;(t)</td>
	<td class="summary">Pairs-like iterator that excludes any keys k of pTable t that are array indices - only iterates over the map-component of the pTable.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.nonNilLen">pT.nonNilLen</a>&nbsp;(lt)</td>
	<td class="summary">Returns the non-nil length/size of the array component of a standard Lua table Simply loops from index 1 until the first nil-valued element.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.pack">pT.pack</a>&nbsp;(...)</td>
	<td class="summary">pTable constructor (table.pack() replacement), which copies the list arguments into the array-component of the newly created pTable.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.packT">pT.packT</a>&nbsp;(...)</td>
	<td class="summary">pTable constructor, which copies all the elements of the argument-list of pTable's into the array-component of a newly created pTable - essentially copies and concatenates the pTable-arrays into a new pTable.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.rarrayPairs">pT.rarrayPairs</a>&nbsp;(t, i)</td>
	<td class="summary">reverse ipairs-replacement for pTable t's array-component and iterates down from t[len(t)] till t[1], and will return possible nil-values - safe(r) element removal.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.regPTable">pT.regPTable</a>&nbsp;(lt, n)</td>
	<td class="summary">Registers an existing standard Lua table lt as a pTable while explicitly providing its length/size n.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.remove">pT.remove</a>&nbsp;(t, i)</td>
	<td class="summary">Removes array-element from pTable t at index i, and returns the removed element's value - t's array size is decreased by one.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.removeNils">pT.removeNils</a>&nbsp;(t)</td>
	<td class="summary">Removes all the elements with nil-values from the array-component of pTable t.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.removeRL">pT.removeRL</a>&nbsp;(t, b, e)</td>
	<td class="summary">Removes the range of array-elements from index b till e from pTable t, and returns those removed elements as a list - t's array size is decreased accordingly.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.removeRT">pT.removeRT</a>&nbsp;(t, b, e)</td>
	<td class="summary">Removes the range of array-elements from index b till e from pTable t, and returns those removed elements in a new pTable - t's array size is decreased accordingly.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.set">pT.set</a>&nbsp;(t, i, v)</td>
	<td class="summary">Set pTable t's element at index i to value v.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.setL">pT.setL</a>&nbsp;(t, i, ...)</td>
	<td class="summary">Copies a list of values into the array-component of pTable t starting at index i Array-size must be able to accomodate the list as it does not grow automatically.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.setT">pT.setT</a>&nbsp;(t, i, ...)</td>
	<td class="summary">Copies the array elements of pTables t1...tn into the array-component of pTable t starting at index i.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.tableKeys">pT.tableKeys</a>&nbsp;(t)</td>
	<td class="summary">Returns a list of all the "lua-defined" keys in table t.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.tableKeysT">pT.tableKeysT</a>&nbsp;(t)</td>
	<td class="summary">Returns a pTable with a list of all the "lua-defined" keys in table t.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.tableLen">pT.tableLen</a>&nbsp;(t)</td>
	<td class="summary">Returns the number of real table entries of t - does not include any nil-assigned array elements.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.unpack">pT.unpack</a>&nbsp;(t, b, e)</td>
	<td class="summary">For the range of array-index b till e of pTable t, returns an list of element values - "pTable-aware" table.unpack() replacement.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#pT.unregPTable">pT.unregPTable</a>&nbsp;(t)</td>
	<td class="summary">Unregisters an existing pTable t such that the pTable-functions won't work with this table anymore.</td>
	</tr>

</table>






<br/>
<br/>




<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="pT.arrayPairs"></a><strong>pT.arrayPairs</strong>&nbsp;(t, i)</dt>
<dd>
ipairs-replacement for pTable t's array-component that iterates up from t[1] till t[len(t)], and will return possible nil-values.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  i: 
	</li>
	
</ul>








</dd>




<dt><a name="pT.arrayPairsSkipNil"></a><strong>pT.arrayPairsSkipNil</strong>&nbsp;(t, i)</dt>
<dd>
ipairs-replacement for pTable t's array-component that iterates up from t[1] till t[len(t)], and will skip any nil-values.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: 
	</li>
	
	<li>
	  i: 
	</li>
	
</ul>








</dd>




<dt><a name="pT.deepCompare"></a><strong>pT.deepCompare</strong>&nbsp;(t1, t2)</dt>
<dd>
Returns result from a deep-compare of object t1 and t2 - compare by value for table elements - iterates down the trees - circular and repeated reference detection.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t1: any kind of object.
	</li>
	
	<li>
	  t2: any kind of object to deep-compare with t1.
	</li>
	
</ul>






<h3>Return value:</h3>
boolean result of deep-comparison.



</dd>




<dt><a name="pT.deepCopy"></a><strong>pT.deepCopy</strong>&nbsp;(t)</dt>
<dd>
Returns a deep copy of object t - iterates "down" the tree if t is a table - pTable-aware - multiple&circular reference aware - copy will share metatable with source.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: any kind of object.
	</li>
	
</ul>






<h3>Return value:</h3>
new deep-copied object



</dd>




<dt><a name="pT.get"></a><strong>pT.get</strong>&nbsp;(t, i)</dt>
<dd>
Returns the array-element value at index i of pTable t.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  i: index (1 <= i <= len(t))
	</li>
	
</ul>






<h3>Return value:</h3>
value at t[i]



</dd>




<dt><a name="pT.getRL"></a><strong>pT.getRL</strong>&nbsp;(t, b, e)</dt>
<dd>
For the range of array-index b till e of pTable t, returns the list of element values. Range must not extend array boundaries. (nil friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  b: start of range - 1 <= b <= len(t) - defaults to 1
	</li>
	
	<li>
	  e: end of range - 1 <= e <= len(t) and e >= b - defaults to len(t)
	</li>
	
</ul>






<h3>Return value:</h3>
list of zero, one or more values (including possible nils)



</dd>




<dt><a name="pT.getRT"></a><strong>pT.getRT</strong>&nbsp;(t, b, e)</dt>
<dd>
For the range of array-index b till e of pTable t, returns an array of element values as a new pTable. Range must not extend array boundaries. (nil friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  b: start of range - 1 <= b <= len(t) - defaults to 1.
	</li>
	
	<li>
	  e: end of range - 1 <= e <= len(t) and e >= b - defaults to len(t).
	</li>
	
</ul>






<h3>Return value:</h3>
new pTable with requested values in the array-components.



</dd>




<dt><a name="pT.insert"></a><strong>pT.insert</strong>&nbsp;(t, iOrV, ...)</dt>
<dd>
Extends and inserts a single value at index i of pTable t - Array-size is increased by one to accomodate the new entry. Existing elements are moved-up - no values are overwritten. i can be len(t)+1, which implies appending to array. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  iOrV: Starting index for insertion or value- nil or no index implies i=len(t)+1 (i.e. append)
	</li>
	
	<li>
	  ...: one value or nothing
	</li>
	
</ul>




<h3>Usage</h3>
<ul>
	
	<li>insert(t,1,"a")
	
	<li>insert(t,"z") -- appends "z" to end of array
	
	<li>insert(t,len(t)+1,nil) -- explicitly append a nil value to t
	
	<li>insert(t,nil,nil) insert(t); insert(t,nil) -- explicitly append a nil value to t
	
</ul>



<h3>Return value:</h3>
modified pTable t



</dd>




<dt><a name="pT.insertL"></a><strong>pT.insertL</strong>&nbsp;(t, i, ...)</dt>
<dd>
Inserts a list of values at index i of pTable t - Array-size is increased to accomodate the list of values. Existing elements are moved-up - no values are overwritten. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  i: Starting index for insertion - nil implies i=len(t)+1 (i.e. append)
	</li>
	
	<li>
	  ...: list of zero, one or more values
	</li>
	
</ul>






<h3>Return value:</h3>
modified pTable t



</dd>




<dt><a name="pT.insertT"></a><strong>pT.insertT</strong>&nbsp;(t, i, ...)</dt>
<dd>
Inserts the array-elements of a list of pTable's at index i of pTable t. Array-size of t is increased to accomodate the list of values. Existing elements are moved-up - no values are overwritten. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable (target)
	</li>
	
	<li>
	  i: Starting index for insertion - nil implies i=len(t)+1 (i.e. append)
	</li>
	
	<li>
	  ...: list of zero, one or more pTables (source) - may include nils, which are ignored.
	</li>
	
</ul>








</dd>




<dt><a name="pT.isIndex"></a><strong>pT.isIndex</strong>&nbsp;(t, k)</dt>
<dd>
Returns whether the key k is a valid index for the array-component of pTable t.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  k: possible array index value
	</li>
	
</ul>






<h3>Return value:</h3>
boolean - true indicates k is integer and 1 <= k <= pT.len(t)



</dd>




<dt><a name="pT.isLuaTableLenOK"></a><strong>pT.isLuaTableLenOK</strong>&nbsp;(lt)</dt>
<dd>
Returns whether the Lua table lt's length may be ambiguous by comparing lt's non-nil array size (nonNilLen(t)) with #lt. This could help determine whether the #t is the length to use for an unknown table.


<h3>Parameters</h3>
<ul>
	
	<li>
	  lt: "standard" lua-table
	</li>
	
</ul>






<h3>Return value:</h3>
Boolean: true if lt's non-nil length equals #lt



</dd>




<dt><a name="pT.isPTable"></a><strong>pT.isPTable</strong>&nbsp;(t)</dt>
<dd>
Returns whether the t is registered as a pTable.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: possible pTable
	</li>
	
</ul>






<h3>Return value:</h3>
boolean - true indicates t has been registered as a pTable



</dd>




<dt><a name="pT.len"></a><strong>pT.len</strong>&nbsp;(t)</dt>
<dd>
Returns length/size of the array component of pTable t.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
</ul>






<h3>Return value:</h3>
Integer >= 0 indicating the size/length of t's array-component



</dd>




<dt><a name="pT.lenT"></a><strong>pT.lenT</strong>&nbsp;(...)</dt>
<dd>
Returns the sum of the array-lengths of a list of pTables: len(t1)+...+len(tn).


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: list of zero, one or more pTables - may include nils, which are ignored.
	</li>
	
</ul>








</dd>




<dt><a name="pT.listPairs"></a><strong>pT.listPairs</strong>&nbsp;(...)</dt>
<dd>
ipairs-like iterator for varargs (friendly to nils).


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: vararg list (may include nils)
	</li>
	
</ul>




<h3>Usage:</h3>
function f(...) for i,a in listPairs(...) do print(i, a) end end





</dd>




<dt><a name="pT.listPairsSkipNil"></a><strong>pT.listPairsSkipNil</strong>&nbsp;(...)</dt>
<dd>
Iterator for varargs (friendly to nils).


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: vararg list (may include nils)
	</li>
	
</ul>




<h3>Usage:</h3>
function f(...) for i,a in apairs(...) do print(i, a) end end





</dd>




<dt><a name="pT.mapKeys"></a><strong>pT.mapKeys</strong>&nbsp;(t)</dt>
<dd>
Returns a list of all the keys of the map-component of pTable t without the array-indices.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable.
	</li>
	
</ul>






<h3>Return value:</h3>
list of t's map-keys.



</dd>




<dt><a name="pT.mapKeysT"></a><strong>pT.mapKeysT</strong>&nbsp;(t)</dt>
<dd>
Returns a pTable with a list of all the keys of the map-component of pTable t without the array-indices.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable.
	</li>
	
</ul>






<h3>Return value:</h3>
new pTable t's map-keys collected in the array-component.



</dd>




<dt><a name="pT.mapLen"></a><strong>pT.mapLen</strong>&nbsp;(t)</dt>
<dd>
Returns the number of map entries in pTable t that are not part of the array-component.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
</ul>






<h3>Return value:</h3>
Integer >= 0 indicating number of t's non-array components



</dd>




<dt><a name="pT.mapNext"></a><strong>pT.mapNext</strong>&nbsp;(t, k)</dt>
<dd>
Next-like iterator that excludes any keys k of pTable t that are array indices - Only iterates over the map-component of the pTable.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: 
	</li>
	
	<li>
	  k: 
	</li>
	
</ul>








</dd>




<dt><a name="pT.mapPairs"></a><strong>pT.mapPairs</strong>&nbsp;(t)</dt>
<dd>
Pairs-like iterator that excludes any keys k of pTable t that are array indices - only iterates over the map-component of the pTable.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: 
	</li>
	
</ul>








</dd>




<dt><a name="pT.nonNilLen"></a><strong>pT.nonNilLen</strong>&nbsp;(lt)</dt>
<dd>
Returns the non-nil length/size of the array component of a standard Lua table Simply loops from index 1 until the first nil-valued element. Note that this function does not set any length/size for t, but merely scans.


<h3>Parameters</h3>
<ul>
	
	<li>
	  lt: table
	</li>
	
</ul>






<h3>Return value:</h3>
size of non-nil array (integer >= 0)



</dd>




<dt><a name="pT.pack"></a><strong>pT.pack</strong>&nbsp;(...)</dt>
<dd>
pTable constructor (table.pack() replacement), which copies the list arguments into the array-component of the newly created pTable. Registers the "correct" argument list size for the array-length. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: List of elements to add to the array-component of the newly created pTable
	</li>
	
</ul>






<h3>Return value:</h3>
New pTable



</dd>




<dt><a name="pT.packT"></a><strong>pT.packT</strong>&nbsp;(...)</dt>
<dd>
pTable constructor, which copies all the elements of the argument-list of pTable's into the array-component of a newly created pTable - essentially copies and concatenates the pTable-arrays into a new pTable. Note that all map-entries of the source-pTable's are ignored. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: List of pTables - may include nils, which are ignored.
	</li>
	
</ul>






<h3>Return value:</h3>
Newly created pTable instance



</dd>




<dt><a name="pT.rarrayPairs"></a><strong>pT.rarrayPairs</strong>&nbsp;(t, i)</dt>
<dd>
reverse ipairs-replacement for pTable t's array-component and iterates down from t[len(t)] till t[1], and will return possible nil-values - safe(r) element removal.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  i: 
	</li>
	
</ul>








</dd>




<dt><a name="pT.regPTable"></a><strong>pT.regPTable</strong>&nbsp;(lt, n)</dt>
<dd>
Registers an existing standard Lua table lt as a pTable while explicitly providing its length/size n. Length/size for table lt has to be passed explicitly as no assumptions about #lt are implicitly trusted/used. (you could use #lt for the argument n value... if you know what you're doing)


<h3>Parameters</h3>
<ul>
	
	<li>
	  lt: An standard lua-table
	</li>
	
	<li>
	  n: Integer >= 0 - indicates the size of the array-component (default is 0)
	</li>
	
</ul>






<h3>Return value:</h3>
pTable lt (unmodified but registered with size n)



</dd>




<dt><a name="pT.remove"></a><strong>pT.remove</strong>&nbsp;(t, i)</dt>
<dd>
Removes array-element from pTable t at index i, and returns the removed element's value - t's array size is decreased by one. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable (changed inplace)
	</li>
	
	<li>
	  i: index of element to remove - default is last element.
	</li>
	
</ul>






<h3>Return value:</h3>
Removed element value.



</dd>




<dt><a name="pT.removeNils"></a><strong>pT.removeNils</strong>&nbsp;(t)</dt>
<dd>
Removes all the elements with nil-values from the array-component of pTable t.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
</ul>






<h3>Return value:</h3>
(possibly modified) pTable t



</dd>




<dt><a name="pT.removeRL"></a><strong>pT.removeRL</strong>&nbsp;(t, b, e)</dt>
<dd>
Removes the range of array-elements from index b till e from pTable t, and returns those removed elements as a list - t's array size is decreased accordingly. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable (changed inplace).
	</li>
	
	<li>
	  b: Starting index for removal (default is b=1).
	</li>
	
	<li>
	  e: Last index for removal (default is e=len(t)).
	</li>
	
</ul>






<h3>Return value:</h3>
List of removed element value(s).



</dd>




<dt><a name="pT.removeRT"></a><strong>pT.removeRT</strong>&nbsp;(t, b, e)</dt>
<dd>
Removes the range of array-elements from index b till e from pTable t, and returns those removed elements in a new pTable - t's array size is decreased accordingly. (nil-friendly)


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable (changed inplace)
	</li>
	
	<li>
	  b: Starting index for removal (default is b=1).
	</li>
	
	<li>
	  e: Last index for removal (default is e=len(t)).
	</li>
	
</ul>






<h3>Return value:</h3>
New pTable with removed element value(s) in the array component.



</dd>




<dt><a name="pT.set"></a><strong>pT.set</strong>&nbsp;(t, i, v)</dt>
<dd>
Set pTable t's element at index i to value v. i should be a valid index for t.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  i: index: 1 <= i <= len(t)
	</li>
	
	<li>
	  v: new value (may be nil)
	</li>
	
</ul>






<h3>Return value:</h3>
modified pTable t



</dd>




<dt><a name="pT.setL"></a><strong>pT.setL</strong>&nbsp;(t, i, ...)</dt>
<dd>
Copies a list of values into the array-component of pTable t starting at index i Array-size must be able to accomodate the list as it does not grow automatically.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  i: target start-index
	</li>
	
	<li>
	  ...: list of zero, one or more values
	</li>
	
</ul>






<h3>Return value:</h3>
modified pTable t



</dd>




<dt><a name="pT.setT"></a><strong>pT.setT</strong>&nbsp;(t, i, ...)</dt>
<dd>
Copies the array elements of pTables t1...tn into the array-component of pTable t starting at index i. t's array-size must be able to accomodate the new elements as it does not grow automatically.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable (target)
	</li>
	
	<li>
	  i: target start-index
	</li>
	
	<li>
	  ...: list of zero, one or more pTable's (source) - may include nils, which are ignored.
	</li>
	
</ul>








</dd>




<dt><a name="pT.tableKeys"></a><strong>pT.tableKeys</strong>&nbsp;(t)</dt>
<dd>
Returns a list of all the "lua-defined" keys in table t.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: lua-table or pTable.
	</li>
	
</ul>






<h3>Return value:</h3>
list of t's keys .



</dd>




<dt><a name="pT.tableKeysT"></a><strong>pT.tableKeysT</strong>&nbsp;(t)</dt>
<dd>
Returns a pTable with a list of all the "lua-defined" keys in table t.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: lua-table or pTable.
	</li>
	
</ul>






<h3>Return value:</h3>
new pTable t's keys collected in the array-component.



</dd>




<dt><a name="pT.tableLen"></a><strong>pT.tableLen</strong>&nbsp;(t)</dt>
<dd>
Returns the number of real table entries of t - does not include any nil-assigned array elements. Simply loops with pairs() over all table entries and counts.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
</ul>






<h3>Return value:</h3>
Integer >= 0 indicating number of truly allocated table entries



</dd>




<dt><a name="pT.unpack"></a><strong>pT.unpack</strong>&nbsp;(t, b, e)</dt>
<dd>
For the range of array-index b till e of pTable t, returns an list of element values - "pTable-aware" table.unpack() replacement. Note that pT.unpack does NOT use any "t.n" that may be used to indicates the array-length.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
	<li>
	  b: start of range to copy - defaults to 1
	</li>
	
	<li>
	  e: end of range to copy - defaults to pT.len(t)
	</li>
	
</ul>






<h3>Return value:</h3>
list of values representing t[b:e] - may include nils



</dd>




<dt><a name="pT.unregPTable"></a><strong>pT.unregPTable</strong>&nbsp;(t)</dt>
<dd>
Unregisters an existing pTable t such that the pTable-functions won't work with this table anymore. When other functions will change this table's size, thru unregPTable() you can prevent accidental use of the pTable functions with the wrong size. It will force the need to re-register the table with the proper size.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: pTable
	</li>
	
</ul>






<h3>Return value:</h3>
t (unmodified but unregistered)



</dd>


</dl>







</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->	
</body>
</html>
